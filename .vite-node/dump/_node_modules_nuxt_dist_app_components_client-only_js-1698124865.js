// /node_modules/nuxt/dist/app/components/client-only.js
const __vite_ssr_import_0__ = await __vite_ssr_import__("vue", {"importedNames":["cloneVNode","createElementBlock","defineComponent","getCurrentInstance","h","onMounted","provide","ref"]});
const __vite_ssr_import_1__ = await __vite_ssr_import__("@vue/shared", {"importedNames":["isPromise"]});
const __vite_ssr_import_2__ = await __vite_ssr_import__("/node_modules/nuxt/dist/app/nuxt.js", {"importedNames":["useNuxtApp"]});
const __vite_ssr_import_3__ = await __vite_ssr_import__("/node_modules/nuxt/dist/app/components/server-placeholder.js", {"importedNames":["default"]});
const __vite_ssr_import_4__ = await __vite_ssr_import__("/node_modules/nuxt/dist/app/components/utils.js", {"importedNames":["elToStaticVNode"]});
const clientOnlySymbol = Symbol.for("nuxt:client-only");
Object.defineProperty(__vite_ssr_exports__, "clientOnlySymbol", { enumerable: true, configurable: true, get(){ return clientOnlySymbol }});
const STATIC_DIV = "<div></div>";
__vite_ssr_exports__.default = (0,__vite_ssr_import_0__.defineComponent)({
  name: "ClientOnly",
  inheritAttrs: false,
  props: ["fallback", "placeholder", "placeholderTag", "fallbackTag"],
  setup(_, { slots, attrs }) {
    const mounted = (0,__vite_ssr_import_0__.ref)(false);
    (0,__vite_ssr_import_0__.onMounted)(() => {
      mounted.value = true;
    });
    if (true) {
      const nuxtApp = (0,__vite_ssr_import_2__.useNuxtApp)();
      nuxtApp._isNuxtPageUsed = true;
      nuxtApp._isNuxtLayoutUsed = true;
    };
    (0,__vite_ssr_import_0__.provide)(clientOnlySymbol, true);
    return (props) => {
      if (mounted.value) {
        return slots.default?.();
      };
      const slot = slots.fallback || slots.placeholder;
      if (slot) {
        return slot();
      };
      const fallbackStr = props.fallback || props.placeholder || "";
      const fallbackTag = props.fallbackTag || props.placeholderTag || "span";
      return (0,__vite_ssr_import_0__.createElementBlock)(fallbackTag, attrs, fallbackStr);
    };
  }
});
const cache = /* @__PURE__ */ new WeakMap();
// @__NO_SIDE_EFFECTS__
function createClientOnly(component) {
  if (true) {
    return __vite_ssr_import_3__.default;
  };
  if (cache.has(component)) {
    return cache.get(component);
  };
  const clone = { ...component };
  if (clone.render) {
    clone.render = (ctx, cache2, $props, $setup, $data, $options) => {
      if ($setup.mounted$ ?? ctx.mounted$) {
        const res = component.render?.bind(ctx)(ctx, cache2, $props, $setup, $data, $options);
        return res.children === null || typeof res.children === "string" ? (0,__vite_ssr_import_0__.cloneVNode)(res) : (0,__vite_ssr_import_0__.h)(res);
      };
      return (0,__vite_ssr_import_4__.elToStaticVNode)(ctx._.vnode.el, STATIC_DIV);
    };
  } else if (clone.template) {
    clone.template = `
      <template v-if="mounted$">${component.template}</template>
      <template v-else>${STATIC_DIV}</template>
    `;
  };
  clone.setup = (props, ctx) => {
    const nuxtApp = (0,__vite_ssr_import_2__.useNuxtApp)();
    const mounted$ = (0,__vite_ssr_import_0__.ref)(nuxtApp.isHydrating === false);
    const instance = (0,__vite_ssr_import_0__.getCurrentInstance)();
    if (nuxtApp.isHydrating) {
      const attrs = { ...instance.attrs };
      const directives = extractDirectives(instance);
      for (const key in attrs) {
        delete instance.attrs[key];
      };
      (0,__vite_ssr_import_0__.onMounted)(() => {
        Object.assign(instance.attrs, attrs);
        instance.vnode.dirs = directives;
      });
    };
    (0,__vite_ssr_import_0__.onMounted)(() => {
      mounted$.value = true;
    });
    const setupState = component.setup?.(props, ctx) || {};
    if ((0,__vite_ssr_import_1__.isPromise)(setupState)) {
      return Promise.resolve(setupState).then((setupState2) => {
        if (typeof setupState2 !== "function") {
          setupState2 ||= {};
          setupState2.mounted$ = mounted$;
          return setupState2;
        };
        return (...args) => {
          if (mounted$.value || !nuxtApp.isHydrating) {
            const res = setupState2(...args);
            return res.children === null || typeof res.children === "string" ? (0,__vite_ssr_import_0__.cloneVNode)(res) : (0,__vite_ssr_import_0__.h)(res);
          };
          return (0,__vite_ssr_import_4__.elToStaticVNode)(instance?.vnode.el, STATIC_DIV);
        };
      });
    } else {
      if (typeof setupState === "function") {
        return (...args) => {
          if (mounted$.value) {
            return (0,__vite_ssr_import_0__.h)(setupState(...args), ctx.attrs);
          };
          return (0,__vite_ssr_import_4__.elToStaticVNode)(instance?.vnode.el, STATIC_DIV);
        };
      };
      return Object.assign(setupState, { mounted$ });
    }
  };
  cache.set(component, clone);
  return clone;
}
Object.defineProperty(__vite_ssr_exports__, "createClientOnly", { enumerable: true, configurable: true, get(){ return createClientOnly }});;
function extractDirectives(instance) {
  if (!instance || !instance.vnode.dirs) {
    return null;
  };
  const directives = instance.vnode.dirs;
  instance.vnode.dirs = null;
  return directives;
}
