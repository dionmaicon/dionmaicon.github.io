// /node_modules/nuxt/dist/pages/runtime/router.options.js
const __vite_ssr_import_0__ = await __vite_ssr_import__("/node_modules/nuxt/dist/app/nuxt.js", {"importedNames":["useNuxtApp"]});
const __vite_ssr_import_1__ = await __vite_ssr_import__("/node_modules/nuxt/dist/app/components/utils.js", {"importedNames":["isChangingPage"]});
const __vite_ssr_import_2__ = await __vite_ssr_import__("/node_modules/nuxt/dist/app/composables/router.js", {"importedNames":["useRouter"]});
const __vite_ssr_import_3__ = await __vite_ssr_import__("/@id/virtual:nuxt:%2Fmedia%2Fdd%2FData%2FProjects%2Fdionmaicon.github.io%2F.nuxt%2Fnuxt.config.mjs", {"importedNames":["appPageTransition"]});
__vite_ssr_exports__.default = {
  scrollBehavior(to, from, savedPosition) {
    const nuxtApp = (0,__vite_ssr_import_0__.useNuxtApp)();
    const behavior = (0,__vite_ssr_import_2__.useRouter)().options?.scrollBehaviorType ?? "auto";
    let position = savedPosition || void 0;
    const routeAllowsScrollToTop = typeof to.meta.scrollToTop === "function" ? to.meta.scrollToTop(to, from) : to.meta.scrollToTop;
    if (!position && from && to && routeAllowsScrollToTop !== false && (0,__vite_ssr_import_1__.isChangingPage)(to, from)) {
      position = { left: 0, top: 0 };
    };
    if (to.path === from.path) {
      if (from.hash && !to.hash) {
        return { left: 0, top: 0 };
      };
      if (to.hash) {
        return { el: to.hash, top: _getHashElementScrollMarginTop(to.hash), behavior };
      };
      return false;
    };
    const hasTransition = (route) => !!(route.meta.pageTransition ?? __vite_ssr_import_3__.appPageTransition);
    const hookToWait = hasTransition(from) && hasTransition(to) ? "page:transition:finish" : "page:finish";
    return new Promise((resolve) => {
      nuxtApp.hooks.hookOnce(hookToWait, async () => {
        await new Promise((resolve2) => setTimeout(resolve2, 0));
        if (to.hash) {
          position = { el: to.hash, top: _getHashElementScrollMarginTop(to.hash), behavior };
        };
        resolve(position);
      });
    });
  }
};
function _getHashElementScrollMarginTop(selector) {
  try {
    const elem = (void 0).querySelector(selector);
    if (elem) {
      return (Number.parseFloat(getComputedStyle(elem).scrollMarginTop) || 0) + (Number.parseFloat(getComputedStyle((void 0).documentElement).scrollPaddingTop) || 0);
    }
  } catch {
  };
  return 0;
}
