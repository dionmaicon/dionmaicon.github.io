// /node_modules/nuxt/dist/app/components/nuxt-link.js
const __vite_ssr_import_0__ = await __vite_ssr_import__("vue", {"importedNames":["computed","defineComponent","h","inject","onBeforeUnmount","onMounted","provide","ref","resolveComponent"]});
const __vite_ssr_import_1__ = await __vite_ssr_import__("ufo", {"importedNames":["hasProtocol","joinURL","parseQuery","withTrailingSlash","withoutTrailingSlash"]});
const __vite_ssr_import_2__ = await __vite_ssr_import__("/node_modules/nuxt/dist/app/composables/preload.js", {"importedNames":["preloadRouteComponents"]});
const __vite_ssr_import_3__ = await __vite_ssr_import__("/node_modules/nuxt/dist/app/composables/ready.js", {"importedNames":["onNuxtReady"]});
const __vite_ssr_import_4__ = await __vite_ssr_import__("/node_modules/nuxt/dist/app/composables/router.js", {"importedNames":["navigateTo","resolveRouteObject","useRouter"]});
const __vite_ssr_import_5__ = await __vite_ssr_import__("/node_modules/nuxt/dist/app/nuxt.js", {"importedNames":["useNuxtApp","useRuntimeConfig"]});
const __vite_ssr_import_6__ = await __vite_ssr_import__("/node_modules/nuxt/dist/app/compat/idle-callback.js", {"importedNames":["cancelIdleCallback","requestIdleCallback"]});
const __vite_ssr_import_7__ = await __vite_ssr_import__("/@id/virtual:nuxt:%2Fmedia%2Fdd%2FData%2FProjects%2Fdionmaicon.github.io%2F.nuxt%2Fnuxt.config.mjs", {"importedNames":["nuxtLinkDefaults"]});
const __vite_ssr_import_8__ = await __vite_ssr_import__("/@id/virtual:nuxt:%2Fmedia%2Fdd%2FData%2FProjects%2Fdionmaicon.github.io%2F.nuxt%2Frouter.options.mjs", {"importedNames":["hashMode"]});
const firstNonUndefined = (...args) => args.find((arg) => arg !== void 0);
const NuxtLinkDevKeySymbol = Symbol("nuxt-link-dev-key");
// @__NO_SIDE_EFFECTS__
function defineNuxtLink(options) {
  const componentName = options.componentName || "NuxtLink";
  function checkPropConflicts(props, main, sub) {
    if (props[main] !== void 0 && props[sub] !== void 0) {
      console.warn(`[${componentName}] \`${main}\` and \`${sub}\` cannot be used together. \`${sub}\` will be ignored.`);
    }
  }
  function isHashLinkWithoutHashMode(link) {
    return !__vite_ssr_import_8__.hashMode && typeof link === "string" && link.startsWith("#");
  }
  function resolveTrailingSlashBehavior(to, resolve) {
    if (!to || options.trailingSlash !== "append" && options.trailingSlash !== "remove") {
      return to;
    };
    if (typeof to === "string") {
      return applyTrailingSlashBehavior(to, options.trailingSlash);
    };
    const path = "path" in to && to.path !== void 0 ? to.path : resolve(to).path;
    const resolvedPath = {
      ...to,
      name: void 0,
      // named routes would otherwise always override trailing slash behavior
      path: applyTrailingSlashBehavior(path, options.trailingSlash)
    };
    return resolvedPath;
  }
  function useNuxtLink(props) {
    const router = (0,__vite_ssr_import_4__.useRouter)();
    const config = (0,__vite_ssr_import_5__.useRuntimeConfig)();
    const hasTarget = (0,__vite_ssr_import_0__.computed)(() => !!props.target && props.target !== "_self");
    const isAbsoluteUrl = (0,__vite_ssr_import_0__.computed)(() => {
      const path = props.to || props.href || "";
      return typeof path === "string" && (0,__vite_ssr_import_1__.hasProtocol)(path, { acceptRelative: true });
    });
    const builtinRouterLink = (0,__vite_ssr_import_0__.resolveComponent)("RouterLink");
    const useBuiltinLink = builtinRouterLink && typeof builtinRouterLink !== "string" ? builtinRouterLink.useLink : void 0;
    const isExternal = (0,__vite_ssr_import_0__.computed)(() => {
      if (props.external) {
        return true;
      };
      const path = props.to || props.href || "";
      if (typeof path === "object") {
        return false;
      };
      return path === "" || isAbsoluteUrl.value;
    });
    const to = (0,__vite_ssr_import_0__.computed)(() => {
      checkPropConflicts(props, "to", "href");
      const path = props.to || props.href || "";
      if (isExternal.value) {
        return path;
      };
      return resolveTrailingSlashBehavior(path, router.resolve);
    });
    const link = isExternal.value ? void 0 : useBuiltinLink?.({ ...props, to });
    const href = (0,__vite_ssr_import_0__.computed)(() => {
      if (!to.value || isAbsoluteUrl.value || isHashLinkWithoutHashMode(to.value)) {
        return to.value;
      };
      if (isExternal.value) {
        const path = typeof to.value === "object" && "path" in to.value ? (0,__vite_ssr_import_4__.resolveRouteObject)(to.value) : to.value;
        const href2 = typeof path === "object" ? router.resolve(path).href : path;
        return resolveTrailingSlashBehavior(
          href2,
          router.resolve
          /* will not be called */
        );
      };
      if (typeof to.value === "object") {
        return router.resolve(to.value)?.href ?? null;
      };
      return resolveTrailingSlashBehavior(
        (0,__vite_ssr_import_1__.joinURL)(config.app.baseURL, to.value),
        router.resolve
        /* will not be called */
      );
    });
    return {
      to,
      hasTarget,
      isAbsoluteUrl,
      isExternal,
      //
      href,
      isActive: link?.isActive ?? (0,__vite_ssr_import_0__.computed)(() => to.value === router.currentRoute.value.path),
      isExactActive: link?.isExactActive ?? (0,__vite_ssr_import_0__.computed)(() => to.value === router.currentRoute.value.path),
      route: link?.route ?? (0,__vite_ssr_import_0__.computed)(() => router.resolve(to.value)),
      async navigate() {
        await (0,__vite_ssr_import_4__.navigateTo)(href.value, { replace: props.replace, external: isExternal.value || hasTarget.value });
      }
    };
  }
  return (0,__vite_ssr_import_0__.defineComponent)({
    name: componentName,
    props: {
      // Routing
      to: {
        type: [String, Object],
        default: void 0,
        required: false
      },
      href: {
        type: [String, Object],
        default: void 0,
        required: false
      },
      // Attributes
      target: {
        type: String,
        default: void 0,
        required: false
      },
      rel: {
        type: String,
        default: void 0,
        required: false
      },
      noRel: {
        type: Boolean,
        default: void 0,
        required: false
      },
      // Prefetching
      prefetch: {
        type: Boolean,
        default: void 0,
        required: false
      },
      prefetchOn: {
        type: [String, Object],
        default: void 0,
        required: false
      },
      noPrefetch: {
        type: Boolean,
        default: void 0,
        required: false
      },
      // Styling
      activeClass: {
        type: String,
        default: void 0,
        required: false
      },
      exactActiveClass: {
        type: String,
        default: void 0,
        required: false
      },
      prefetchedClass: {
        type: String,
        default: void 0,
        required: false
      },
      // Vue Router's `<RouterLink>` additional props
      replace: {
        type: Boolean,
        default: void 0,
        required: false
      },
      ariaCurrentValue: {
        type: String,
        default: void 0,
        required: false
      },
      // Edge cases handling
      external: {
        type: Boolean,
        default: void 0,
        required: false
      },
      // Slot API
      custom: {
        type: Boolean,
        default: void 0,
        required: false
      }
    },
    useLink: useNuxtLink,
    setup(props, { slots }) {
      const router = (0,__vite_ssr_import_4__.useRouter)();
      const { to, href, navigate, isExternal, hasTarget, isAbsoluteUrl } = useNuxtLink(props);
      const prefetched = (0,__vite_ssr_import_0__.ref)(false);
      const el = true ? void 0 : (0,__vite_ssr_import_0__.ref)(null);
      const elRef = true ? void 0 : (ref2) => {
        el.value = props.custom ? ref2?.$el?.nextElementSibling : ref2?.$el;
      };
      function shouldPrefetch(mode) {
        if (true) {
          return;
        };
        return !prefetched.value && (typeof props.prefetchOn === "string" ? props.prefetchOn === mode : props.prefetchOn?.[mode] ?? options.prefetchOn?.[mode]) && (props.prefetch ?? options.prefetch) !== false && props.noPrefetch !== true && props.target !== "_blank" && !isSlowConnection();
      }
      async function prefetch(nuxtApp = (0,__vite_ssr_import_5__.useNuxtApp)()) {
        if (true) {
          return;
        };
        if (prefetched.value) {
          return;
        };
        prefetched.value = true;
        const path = typeof to.value === "string" ? to.value : isExternal.value ? (0,__vite_ssr_import_4__.resolveRouteObject)(to.value) : router.resolve(to.value).fullPath;
        const normalizedPath = isExternal.value ? new URL(path, (void 0).location.href).href : path;
        await Promise.all([
          nuxtApp.hooks.callHook("link:prefetch", normalizedPath).catch(() => {
          }),
          !isExternal.value && !hasTarget.value && (0,__vite_ssr_import_2__.preloadRouteComponents)(to.value, router).catch(() => {
          })
        ]);
      }
      if (false) {
        checkPropConflicts(props, "prefetch", "noPrefetch");
        if (shouldPrefetch("visibility")) {
          const nuxtApp = (0,__vite_ssr_import_5__.useNuxtApp)();
          let idleId;
          let unobserve = null;
          (0,__vite_ssr_import_0__.onMounted)(() => {
            const observer = useObserver();
            (0,__vite_ssr_import_3__.onNuxtReady)(() => {
              idleId = (0,__vite_ssr_import_6__.requestIdleCallback)(() => {
                if (el?.value?.tagName) {
                  unobserve = observer.observe(el.value, async () => {
                    unobserve?.();
                    unobserve = null;
                    await prefetch(nuxtApp);
                  });
                }
              });
            });
          });
          (0,__vite_ssr_import_0__.onBeforeUnmount)(() => {
            if (idleId) {
              (0,__vite_ssr_import_6__.cancelIdleCallback)(idleId);
            };
            unobserve?.();
            unobserve = null;
          });
        }
      };
      if (!props.custom) {
        const isNuxtLinkChild = (0,__vite_ssr_import_0__.inject)(NuxtLinkDevKeySymbol, false);
        if (isNuxtLinkChild) {
          console.log("[nuxt] [NuxtLink] You can't nest one <a> inside another <a>. This will cause a hydration error on client-side. You can pass the `custom` prop to take full control of the markup.");
        } else {
          (0,__vite_ssr_import_0__.provide)(NuxtLinkDevKeySymbol, true);
        }
      };
      return () => {
        if (!isExternal.value && !hasTarget.value && !isHashLinkWithoutHashMode(to.value)) {
          const routerLinkProps = {
            ref: elRef,
            to: to.value,
            activeClass: props.activeClass || options.activeClass,
            exactActiveClass: props.exactActiveClass || options.exactActiveClass,
            replace: props.replace,
            ariaCurrentValue: props.ariaCurrentValue,
            custom: props.custom
          };
          if (!props.custom) {
            if (false) {
              if (shouldPrefetch("interaction")) {
                routerLinkProps.onPointerenter = prefetch.bind(null, void 0);
                routerLinkProps.onFocus = prefetch.bind(null, void 0);
              };
              if (prefetched.value) {
                routerLinkProps.class = props.prefetchedClass || options.prefetchedClass;
              }
            };
            routerLinkProps.rel = props.rel || void 0;
          };
          return (0,__vite_ssr_import_0__.h)(
            (0,__vite_ssr_import_0__.resolveComponent)("RouterLink"),
            routerLinkProps,
            slots.default
          );
        };
        const target = props.target || null;
        checkPropConflicts(props, "noRel", "rel");
        const rel = firstNonUndefined(
          // converts `""` to `null` to prevent the attribute from being added as empty (`rel=""`)
          props.noRel ? "" : props.rel,
          options.externalRelAttribute,
          /*
          * A fallback rel of `noopener noreferrer` is applied for external links or links that open in a new tab.
          * This solves a reverse tabnapping security flaw in browsers pre-2021 as well as improving privacy.
          */
          isAbsoluteUrl.value || hasTarget.value ? "noopener noreferrer" : ""
        ) || null;
        if (props.custom) {
          if (!slots.default) {
            return null;
          };
          return slots.default({
            href: href.value,
            navigate,
            prefetch,
            get route() {
              if (!href.value) {
                return void 0;
              };
              const url = new URL(href.value, false ? (void 0).location.href : "http://localhost");
              return {
                path: url.pathname,
                fullPath: url.pathname,
                get query() {
                  return (0,__vite_ssr_import_1__.parseQuery)(url.search);
                },
                hash: url.hash,
                params: {},
                name: void 0,
                matched: [],
                redirectedFrom: void 0,
                meta: {},
                href: href.value
              };
            },
            rel,
            target,
            isExternal: isExternal.value || hasTarget.value,
            isActive: false,
            isExactActive: false
          });
        };
        return (0,__vite_ssr_import_0__.h)("a", { ref: el, href: href.value || null, rel, target }, slots.default?.());
      };
    }
  });
}
Object.defineProperty(__vite_ssr_exports__, "defineNuxtLink", { enumerable: true, configurable: true, get(){ return defineNuxtLink }});;
__vite_ssr_exports__.default = /* @__PURE__ */ defineNuxtLink((0,__vite_ssr_import_7__.nuxtLinkDefaults));
function applyTrailingSlashBehavior(to, trailingSlash) {
  const normalizeFn = trailingSlash === "append" ? __vite_ssr_import_1__.withTrailingSlash : __vite_ssr_import_1__.withoutTrailingSlash;
  const hasProtocolDifferentFromHttp = (0,__vite_ssr_import_1__.hasProtocol)(to) && !to.startsWith("http");
  if (hasProtocolDifferentFromHttp) {
    return to;
  };
  return normalizeFn(to, true);
}
function useObserver() {
  if (true) {
    return;
  };
  const nuxtApp = (0,__vite_ssr_import_5__.useNuxtApp)();
  if (nuxtApp._observer) {
    return nuxtApp._observer;
  };
  let observer = null;
  const callbacks = /* @__PURE__ */ new Map();
  const observe = (element, callback) => {
    if (!observer) {
      observer = new IntersectionObserver((entries) => {
        for (const entry of entries) {
          const callback2 = callbacks.get(entry.target);
          const isVisible = entry.isIntersecting || entry.intersectionRatio > 0;
          if (isVisible && callback2) {
            callback2();
          }
        }
      });
    };
    callbacks.set(element, callback);
    observer.observe(element);
    return () => {
      callbacks.delete(element);
      observer?.unobserve(element);
      if (callbacks.size === 0) {
        observer?.disconnect();
        observer = null;
      }
    };
  };
  const _observer = nuxtApp._observer = {
    observe
  };
  return _observer;
}
const IS_2G_RE = /2g/;
function isSlowConnection() {
  if (true) {
    return;
  };
  const cn = (void 0).connection;
  if (cn && (cn.saveData || IS_2G_RE.test(cn.effectiveType))) {
    return true;
  };
  return false;
}
