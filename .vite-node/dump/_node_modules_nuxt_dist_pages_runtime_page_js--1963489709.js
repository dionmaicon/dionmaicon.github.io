// /node_modules/nuxt/dist/pages/runtime/page.js
const __vite_ssr_import_0__ = await __vite_ssr_import__("vue", {"importedNames":["Fragment","Suspense","defineComponent","h","inject","nextTick","ref","watch"]});
const __vite_ssr_import_1__ = await __vite_ssr_import__("vue-router", {"importedNames":["RouterView"]});
const __vite_ssr_import_2__ = await __vite_ssr_import__("defu", {"importedNames":["defu"]});
const __vite_ssr_import_3__ = await __vite_ssr_import__("/node_modules/nuxt/dist/pages/runtime/utils.js", {"importedNames":["generateRouteKey","toArray","wrapInKeepAlive"]});
const __vite_ssr_import_4__ = await __vite_ssr_import__("/node_modules/nuxt/dist/app/components/route-provider.js", {"importedNames":["RouteProvider"]});
const __vite_ssr_import_5__ = await __vite_ssr_import__("/node_modules/nuxt/dist/app/nuxt.js", {"importedNames":["useNuxtApp"]});
const __vite_ssr_import_6__ = await __vite_ssr_import__("/node_modules/nuxt/dist/app/composables/router.js", {"importedNames":["useRouter"]});
const __vite_ssr_import_7__ = await __vite_ssr_import__("/node_modules/nuxt/dist/app/components/utils.js", {"importedNames":["_wrapInTransition"]});
const __vite_ssr_import_8__ = await __vite_ssr_import__("/node_modules/nuxt/dist/app/components/injections.js", {"importedNames":["LayoutMetaSymbol","PageRouteSymbol"]});
const __vite_ssr_import_9__ = await __vite_ssr_import__("/@id/virtual:nuxt:%2Fmedia%2Fdd%2FData%2FProjects%2Fdionmaicon.github.io%2F.nuxt%2Fnuxt.config.mjs", {"importedNames":["appKeepalive","appPageTransition"]});
__vite_ssr_exports__.default = (0,__vite_ssr_import_0__.defineComponent)({
  name: "NuxtPage",
  inheritAttrs: false,
  props: {
    name: {
      type: String
    },
    transition: {
      type: [Boolean, Object],
      default: void 0
    },
    keepalive: {
      type: [Boolean, Object],
      default: void 0
    },
    route: {
      type: Object
    },
    pageKey: {
      type: [Function, String],
      default: null
    }
  },
  setup(props, { attrs, slots, expose }) {
    const nuxtApp = (0,__vite_ssr_import_5__.useNuxtApp)();
    const pageRef = (0,__vite_ssr_import_0__.ref)();
    const forkRoute = (0,__vite_ssr_import_0__.inject)((0,__vite_ssr_import_8__.PageRouteSymbol), null);
    let previousPageKey;
    expose({ pageRef });
    const _layoutMeta = (0,__vite_ssr_import_0__.inject)((0,__vite_ssr_import_8__.LayoutMetaSymbol), null);
    let vnode;
    const done = nuxtApp.deferHydration();
    if (false && nuxtApp.isHydrating) {
      const removeErrorHook = nuxtApp.hooks.hookOnce("app:error", done);
      (0,__vite_ssr_import_6__.useRouter)().beforeEach(removeErrorHook);
    };
    if (props.pageKey) {
      (0,__vite_ssr_import_0__.watch)(() => props.pageKey, (next, prev) => {
        if (next !== prev) {
          nuxtApp.callHook("page:loading:start");
        }
      });
    };
    if (true) {
      nuxtApp._isNuxtPageUsed = true;
    };
    let pageLoadingEndHookAlreadyCalled = false;
    return () => {
      return (0,__vite_ssr_import_0__.h)((0,__vite_ssr_import_1__.RouterView), { name: props.name, route: props.route, ...attrs }, {
        default: (routeProps) => {
          const isRenderingNewRouteInOldFork = false && haveParentRoutesRendered(forkRoute, routeProps.route, routeProps.Component);
          const hasSameChildren = false && forkRoute && forkRoute.matched.length === routeProps.route.matched.length;
          if (!routeProps.Component) {
            if (false && vnode && !hasSameChildren) {
              return vnode;
            };
            done();
            return;
          };
          if (false && vnode && _layoutMeta && !_layoutMeta.isCurrent(routeProps.route)) {
            return vnode;
          };
          if (false && isRenderingNewRouteInOldFork && forkRoute && (!_layoutMeta || _layoutMeta?.isCurrent(forkRoute))) {
            if (hasSameChildren) {
              return vnode;
            };
            return null;
          };
          const key = (0,__vite_ssr_import_3__.generateRouteKey)(routeProps, props.pageKey);
          if (!nuxtApp.isHydrating && !hasChildrenRoutes(forkRoute, routeProps.route, routeProps.Component) && previousPageKey === key) {
            nuxtApp.callHook("page:loading:end");
            pageLoadingEndHookAlreadyCalled = true;
          };
          previousPageKey = key;
          if (true) {
            vnode = (0,__vite_ssr_import_0__.h)((0,__vite_ssr_import_0__.Suspense), {
              suspensible: true
            }, {
              default: () => {
                const providerVNode = (0,__vite_ssr_import_0__.h)((0,__vite_ssr_import_4__.RouteProvider), {
                  key: key || void 0,
                  vnode: slots.default ? (0,__vite_ssr_import_0__.h)((0,__vite_ssr_import_0__.Fragment), void 0, slots.default(routeProps)) : routeProps.Component,
                  route: routeProps.route,
                  renderKey: key || void 0,
                  vnodeRef: pageRef
                });
                return providerVNode;
              }
            });
            return vnode;
          };
          const hasTransition = !!(props.transition ?? routeProps.route.meta.pageTransition ?? __vite_ssr_import_9__.appPageTransition);
          const transitionProps = hasTransition && _mergeTransitionProps([
            props.transition,
            routeProps.route.meta.pageTransition,
            __vite_ssr_import_9__.appPageTransition,
            { onAfterLeave: () => {
              nuxtApp.callHook("page:transition:finish", routeProps.Component);
            } }
          ].filter(Boolean));
          const keepaliveConfig = props.keepalive ?? routeProps.route.meta.keepalive ?? __vite_ssr_import_9__.appKeepalive;
          vnode = (0,__vite_ssr_import_7__._wrapInTransition)(
            hasTransition && transitionProps,
            (0,__vite_ssr_import_3__.wrapInKeepAlive)(
              keepaliveConfig,
              (0,__vite_ssr_import_0__.h)((0,__vite_ssr_import_0__.Suspense), {
                suspensible: true,
                onPending: () => nuxtApp.callHook("page:start", routeProps.Component),
                onResolve: () => {
                  (0,__vite_ssr_import_0__.nextTick)(() => nuxtApp.callHook("page:finish", routeProps.Component).then(() => {
                    if (!pageLoadingEndHookAlreadyCalled) {
                      return nuxtApp.callHook("page:loading:end");
                    };
                    pageLoadingEndHookAlreadyCalled = false;
                  }).finally(done));
                }
              }, {
                default: () => {
                  const providerVNode = (0,__vite_ssr_import_0__.h)((0,__vite_ssr_import_4__.RouteProvider), {
                    key: key || void 0,
                    vnode: slots.default ? (0,__vite_ssr_import_0__.h)((0,__vite_ssr_import_0__.Fragment), void 0, slots.default(routeProps)) : routeProps.Component,
                    route: routeProps.route,
                    renderKey: key || void 0,
                    trackRootNodes: hasTransition,
                    vnodeRef: pageRef
                  });
                  if (keepaliveConfig) {
                    providerVNode.type.name = routeProps.Component.type.name || routeProps.Component.type.__name || "RouteProvider";
                  };
                  return providerVNode;
                }
              })
            )
          ).default();
          return vnode;
        }
      });
    };
  }
});
function _mergeTransitionProps(routeProps) {
  const _props = routeProps.map((prop) => ({
    ...prop,
    onAfterLeave: prop.onAfterLeave ? (0,__vite_ssr_import_3__.toArray)(prop.onAfterLeave) : void 0
  }));
  return (0,__vite_ssr_import_2__.defu)(..._props);
}
function haveParentRoutesRendered(fork, newRoute, Component) {
  if (!fork) {
    return false;
  };
  const index = newRoute.matched.findIndex((m) => m.components?.default === Component?.type);
  if (!index || index === -1) {
    return false;
  };
  return newRoute.matched.slice(0, index).some(
    (c, i) => c.components?.default !== fork.matched[i]?.components?.default
  ) || Component && (0,__vite_ssr_import_3__.generateRouteKey)({ route: newRoute, Component }) !== (0,__vite_ssr_import_3__.generateRouteKey)({ route: fork, Component });
}
function hasChildrenRoutes(fork, newRoute, Component) {
  if (!fork) {
    return false;
  };
  const index = newRoute.matched.findIndex((m) => m.components?.default === Component?.type);
  return index < newRoute.matched.length - 1;
}
