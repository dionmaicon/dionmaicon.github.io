// /node_modules/nuxt/dist/app/nuxt.js
const __vite_ssr_import_0__ = await __vite_ssr_import__("vue", {"importedNames":["effectScope","getCurrentInstance","getCurrentScope","hasInjectionContext","reactive","shallowReactive"]});
const __vite_ssr_import_1__ = await __vite_ssr_import__("hookable", {"importedNames":["createHooks"]});
const __vite_ssr_import_2__ = await __vite_ssr_import__("unctx", {"importedNames":["getContext"]});
const __vite_ssr_import_3__ = await __vite_ssr_import__("/@id/virtual:nuxt:%2Fmedia%2Fdd%2FData%2FProjects%2Fdionmaicon.github.io%2F.nuxt%2Fnuxt.config.mjs", {"importedNames":["appId","chunkErrorEvent","multiApp"]});
function getNuxtAppCtx(id = __vite_ssr_import_3__.appId || "nuxt-app") {
  return (0,__vite_ssr_import_2__.getContext)(id, {
    asyncContext: false
  });
}
const NuxtPluginIndicator = "__nuxt_plugin";
Object.defineProperty(__vite_ssr_exports__, "NuxtPluginIndicator", { enumerable: true, configurable: true, get(){ return NuxtPluginIndicator }});
function createNuxtApp(options) {
  let hydratingCount = 0;
  const nuxtApp = {
    _id: options.id || __vite_ssr_import_3__.appId || "nuxt-app",
    _scope: (0,__vite_ssr_import_0__.effectScope)(),
    provide: void 0,
    globalName: "nuxt",
    versions: {
      get nuxt() {
        return "3.15.4";
      },
      get vue() {
        return nuxtApp.vueApp.version;
      }
    },
    payload: (0,__vite_ssr_import_0__.shallowReactive)({
      ...options.ssrContext?.payload || {},
      data: (0,__vite_ssr_import_0__.shallowReactive)({}),
      state: (0,__vite_ssr_import_0__.reactive)({}),
      once: /* @__PURE__ */ new Set(),
      _errors: (0,__vite_ssr_import_0__.shallowReactive)({})
    }),
    static: {
      data: {}
    },
    runWithContext(fn) {
      if (nuxtApp._scope.active && !(0,__vite_ssr_import_0__.getCurrentScope)()) {
        return nuxtApp._scope.run(() => callWithNuxt(nuxtApp, fn));
      };
      return callWithNuxt(nuxtApp, fn);
    },
    isHydrating: false,
    deferHydration() {
      if (!nuxtApp.isHydrating) {
        return () => {
        };
      };
      hydratingCount++;
      let called = false;
      return () => {
        if (called) {
          return;
        };
        called = true;
        hydratingCount--;
        if (hydratingCount === 0) {
          nuxtApp.isHydrating = false;
          return nuxtApp.callHook("app:suspense:resolve");
        }
      };
    },
    _asyncDataPromises: {},
    _asyncData: (0,__vite_ssr_import_0__.shallowReactive)({}),
    _payloadRevivers: {},
    ...options
  };
  if (true) {
    nuxtApp.payload.serverRendered = true;
  };
  if (nuxtApp.ssrContext) {
    nuxtApp.payload.path = nuxtApp.ssrContext.url;
    nuxtApp.ssrContext.nuxt = nuxtApp;
    nuxtApp.ssrContext.payload = nuxtApp.payload;
    nuxtApp.ssrContext.config = {
      public: nuxtApp.ssrContext.runtimeConfig.public,
      app: nuxtApp.ssrContext.runtimeConfig.app
    };
  };
  if (false) {
    const __NUXT__ = __vite_ssr_import_3__.multiApp ? (void 0).__NUXT__?.[nuxtApp._id] : (void 0).__NUXT__;
    if (__NUXT__) {
      for (const key in __NUXT__) {
        switch (key) {
          case "data":
          case "state":
          case "_errors":
            Object.assign(nuxtApp.payload[key], __NUXT__[key]);
            break;
          default:
            nuxtApp.payload[key] = __NUXT__[key];
        }
      }
    }
  };
  nuxtApp.hooks = (0,__vite_ssr_import_1__.createHooks)();
  nuxtApp.hook = nuxtApp.hooks.hook;
  if (true) {
    const contextCaller = async function(hooks, args) {
      for (const hook of hooks) {
        await nuxtApp.runWithContext(() => hook(...args));
      }
    };
    nuxtApp.hooks.callHook = (name, ...args) => nuxtApp.hooks.callHookWith(contextCaller, name, ...args);
  };
  nuxtApp.callHook = nuxtApp.hooks.callHook;
  nuxtApp.provide = (name, value) => {
    const $name = "$" + name;
    defineGetter(nuxtApp, $name, value);
    defineGetter(nuxtApp.vueApp.config.globalProperties, $name, value);
  };
  defineGetter(nuxtApp.vueApp, "$nuxt", nuxtApp);
  defineGetter(nuxtApp.vueApp.config.globalProperties, "$nuxt", nuxtApp);
  if (false) {
    if (__vite_ssr_import_3__.chunkErrorEvent) {
      (void 0).addEventListener((0,__vite_ssr_import_3__.chunkErrorEvent), (event) => {
        nuxtApp.callHook("app:chunkError", { error: event.payload });
        if (nuxtApp.isHydrating || event.payload.message.includes("Unable to preload CSS")) {
          event.preventDefault();
        }
      });
    };
    (void 0).useNuxtApp = (void 0).useNuxtApp || useNuxtApp;
    const unreg = nuxtApp.hook("app:error", (...args) => {
      console.error("[nuxt] error caught during app initialization", ...args);
    });
    nuxtApp.hook("app:mounted", unreg);
  };
  const runtimeConfig = true ? options.ssrContext.runtimeConfig : nuxtApp.payload.config;
  nuxtApp.provide("config", false ? wrappedConfig(runtimeConfig) : runtimeConfig);
  return nuxtApp;
}
Object.defineProperty(__vite_ssr_exports__, "createNuxtApp", { enumerable: true, configurable: true, get(){ return createNuxtApp }});;
function registerPluginHooks(nuxtApp, plugin) {
  if (plugin.hooks) {
    nuxtApp.hooks.addHooks(plugin.hooks);
  }
}
Object.defineProperty(__vite_ssr_exports__, "registerPluginHooks", { enumerable: true, configurable: true, get(){ return registerPluginHooks }});;
async function applyPlugin(nuxtApp, plugin) {
  if (typeof plugin === "function") {
    const { provide } = await nuxtApp.runWithContext(() => plugin(nuxtApp)) || {};
    if (provide && typeof provide === "object") {
      for (const key in provide) {
        nuxtApp.provide(key, provide[key]);
      }
    }
  }
}
Object.defineProperty(__vite_ssr_exports__, "applyPlugin", { enumerable: true, configurable: true, get(){ return applyPlugin }});;
async function applyPlugins(nuxtApp, plugins) {
  const resolvedPlugins = [];
  const unresolvedPlugins = [];
  const parallels = [];
  const errors = [];
  let promiseDepth = 0;
  async function executePlugin(plugin) {
    const unresolvedPluginsForThisPlugin = plugin.dependsOn?.filter((name) => plugins.some((p) => p._name === name) && !resolvedPlugins.includes(name)) ?? [];
    if (unresolvedPluginsForThisPlugin.length > 0) {
      unresolvedPlugins.push([new Set(unresolvedPluginsForThisPlugin), plugin]);
    } else {
      const promise = applyPlugin(nuxtApp, plugin).then(async () => {
        if (plugin._name) {
          resolvedPlugins.push(plugin._name);
          await Promise.all(unresolvedPlugins.map(async ([dependsOn, unexecutedPlugin]) => {
            if (dependsOn.has(plugin._name)) {
              dependsOn.delete(plugin._name);
              if (dependsOn.size === 0) {
                promiseDepth++;
                await executePlugin(unexecutedPlugin);
              }
            }
          }));
        }
      });
      if (plugin.parallel) {
        parallels.push(promise.catch((e) => errors.push(e)));
      } else {
        await promise;
      }
    }
  }
  for (const plugin of plugins) {
    if (nuxtApp.ssrContext?.islandContext && plugin.env?.islands === false) {
      continue;
    };
    registerPluginHooks(nuxtApp, plugin);
  };
  for (const plugin of plugins) {
    if (nuxtApp.ssrContext?.islandContext && plugin.env?.islands === false) {
      continue;
    };
    await executePlugin(plugin);
  };
  await Promise.all(parallels);
  if (promiseDepth) {
    for (let i = 0; i < promiseDepth; i++) {
      await Promise.all(parallels);
    }
  };
  if (errors.length) {
    throw errors[0];
  }
}
Object.defineProperty(__vite_ssr_exports__, "applyPlugins", { enumerable: true, configurable: true, get(){ return applyPlugins }});;
// @__NO_SIDE_EFFECTS__
function defineNuxtPlugin(plugin) {
  if (typeof plugin === "function") {
    return plugin;
  };
  const _name = plugin._name || plugin.name;
  delete plugin.name;
  return Object.assign(plugin.setup || (() => {
  }), plugin, { [NuxtPluginIndicator]: true, _name });
}
Object.defineProperty(__vite_ssr_exports__, "defineNuxtPlugin", { enumerable: true, configurable: true, get(){ return defineNuxtPlugin }});;
const definePayloadPlugin = defineNuxtPlugin;
Object.defineProperty(__vite_ssr_exports__, "definePayloadPlugin", { enumerable: true, configurable: true, get(){ return definePayloadPlugin }});
function isNuxtPlugin(plugin) {
  return typeof plugin === "function" && NuxtPluginIndicator in plugin;
}
Object.defineProperty(__vite_ssr_exports__, "isNuxtPlugin", { enumerable: true, configurable: true, get(){ return isNuxtPlugin }});;
function callWithNuxt(nuxt, setup, args) {
  const fn = () => args ? setup(...args) : setup();
  const nuxtAppCtx = getNuxtAppCtx(nuxt._id);
  if (true) {
    return nuxt.vueApp.runWithContext(() => nuxtAppCtx.callAsync(nuxt, fn));
  } else {
    nuxtAppCtx.set(nuxt);
    return nuxt.vueApp.runWithContext(fn);
  }
}
Object.defineProperty(__vite_ssr_exports__, "callWithNuxt", { enumerable: true, configurable: true, get(){ return callWithNuxt }});;
function tryUseNuxtApp(id) {
  let nuxtAppInstance;
  if ((0,__vite_ssr_import_0__.hasInjectionContext)()) {
    nuxtAppInstance = (0,__vite_ssr_import_0__.getCurrentInstance)()?.appContext.app.$nuxt;
  };
  nuxtAppInstance = nuxtAppInstance || getNuxtAppCtx(id).tryUse();
  return nuxtAppInstance || null;
}
Object.defineProperty(__vite_ssr_exports__, "tryUseNuxtApp", { enumerable: true, configurable: true, get(){ return tryUseNuxtApp }});;
function useNuxtApp(id) {
  const nuxtAppInstance = tryUseNuxtApp(id);
  if (!nuxtAppInstance) {
    if (true) {
      throw new Error("[nuxt] A composable that requires access to the Nuxt instance was called outside of a plugin, Nuxt hook, Nuxt middleware, or Vue setup function. This is probably not a Nuxt bug. Find out more at `https://nuxt.com/docs/guide/concepts/auto-imports#vue-and-nuxt-composables`.");
    } else {
      throw new Error("[nuxt] instance unavailable");
    }
  };
  return nuxtAppInstance;
}
Object.defineProperty(__vite_ssr_exports__, "useNuxtApp", { enumerable: true, configurable: true, get(){ return useNuxtApp }});;
// @__NO_SIDE_EFFECTS__
function useRuntimeConfig(_event) {
  return useNuxtApp().$config;
}
Object.defineProperty(__vite_ssr_exports__, "useRuntimeConfig", { enumerable: true, configurable: true, get(){ return useRuntimeConfig }});;
function defineGetter(obj, key, val) {
  Object.defineProperty(obj, key, { get: () => val });
}
function defineAppConfig(config) {
  return config;
}
Object.defineProperty(__vite_ssr_exports__, "defineAppConfig", { enumerable: true, configurable: true, get(){ return defineAppConfig }});;
const loggedKeys = /* @__PURE__ */ new Set();
function wrappedConfig(runtimeConfig) {
  if (true) {
    return runtimeConfig;
  };
  const keys = Object.keys(runtimeConfig).map((key) => `\`${key}\``);
  const lastKey = keys.pop();
  return new Proxy(runtimeConfig, {
    get(target, p, receiver) {
      if (typeof p === "string" && p !== "public" && !(p in target) && !p.startsWith("__v")) {
        if (!loggedKeys.has(p)) {
          loggedKeys.add(p);
          console.warn(`[nuxt] Could not access \`${p}\`. The only available runtime config keys on the client side are ${keys.join(", ")} and ${lastKey}. See https://nuxt.com/docs/guide/going-further/runtime-config for more information.`);
        }
      };
      return Reflect.get(target, p, receiver);
    }
  });
}
